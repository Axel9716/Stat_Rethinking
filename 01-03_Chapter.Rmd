---
title: "practice"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
globe.qa <- quap(
  alist(
    W ~ dbinom(W+L, p),
    p ~ dunif(0,1)
  ),
  data = list(W=6,L=3) )

precis(globe.qa)

# analytical calculation
W <- 6
L <- 3
curve( dbeta( x , W+1 , L+1 ) , from=0 , to=1 )
# quadratic approximation
curve( dnorm( x , 0.67 , 0.16 ) , lty=2 , add=TRUE )
```

```{r}
n_samples <- 1000
p <- rep( NA , n_samples )
p[1] <- 0.5
W <- 6
L <- 3
for ( i in 2:n_samples ) {
p_new <- rnorm( 1 , p[i-1] , 0.1 )
if ( p_new < 0 ) p_new <- abs( p_new )
if ( p_new > 1 ) p_new <- 2 - p_new
q0 <- dbinom( W , W+L , p[i-1] )
q1 <- dbinom( W , W+L , p_new )
p[i] <- ifelse( runif(1) < q1/q0 , p_new , p[i-1] )
}

dens( p , xlim=c(0,1) )
curve( dbeta( x , W+1 , L+1 ) , lty=2 , add=TRUE )
```



```{r}
post_samples <- rbeta(1e4, 6+1, 3+1)
w <- rbinom(1e4, size=90000, prob=0.6666)

hist(w, freq = FALSE)
hist(post_samples, freq = TRUE)
```



# Chapter 1


#Grid Approximation

```{r}
pgrid <- seq(0,1, length.out=100)
prior <- rep(1, 100)
likelihood <- dbinom(6,9, prob = pgrid)
unstd_posterior <- likelihood*pgrid
posterior <- unstd_posterior/sum(unstd_posterior)

plot(pgrid, prior, type = "b")

sum(posterior)
```

# Quadratic Approximation

```{r}
globe_qa <- quap(
  alist(
    W ~ dbinom(W+L, p),
    p ~ dunif(0,1)
  ),
  data = list(W=6,L=3)
)

precis(globe_qa)

globe_param <- precis(globe_qa)
```


```{r}
W <- 6
L <- 3
curve(dbeta(x, 7, 4), from = 0, to = 1)
curve(dbeta(x, W+1, L+1), from = 0, to = 1)
curve(dnorm(x, globe_param[,1], globe_param[,2]), add = TRUE, lty = 9)
```


#Markov Chain Monte Carlo

```{r}
n_samples <- 100000
p <- rep(NA, n_samples)
p[1] <- 0.5
W <- 20
L <- 1

for ( i in 2:n_samples ) {
p_new <- rnorm( 1 , p[i-1] , 0.1 ) # takes one sample from norm dist with mean p[i-1] and sd 0.1
if ( p_new < 0 ) p_new <- abs( p_new ) # makes negative p's positive
if ( p_new > 1 ) p_new <- 2 - p_new # keeps p between 0-1
q0 <- dbinom( W , W+L , p[i-1] ) 
q1 <- dbinom( W , W+L , p_new )
p[i] <- ifelse( runif(1) < q1/q0 , p_new , p[i-1] )
}

```


```{r}
dens(p, xlim = c(0,1))
curve(dbeta(x, W+1, L+1), add = TRUE, lty = 2)
```


# 2M2

```{r}
pgrid <- seq(0,1, length.out=100)
prior <- ifelse(pgrid < .5, 0, 1)
likelihood <- dbinom(5, 7, prob=pgrid)
unstd_posterior <- likelihood*prior
posterior <- unstd_posterior/sum(unstd_posterior)

plot(pgrid, prior)
```




# Chapter 3

# Sample Grid approximated Posterior

```{r}
pgrid <- seq(0,1, length.out = 100)
prior <- rep(1,100)
likelihood <- dbinom(6,9, prob = pgrid)
unstd_posterior <- likelihood*prior
posterior <-  unstd_posterior/sum(unstd_posterior)

grid_sample <- sample(pgrid, prob = posterior, 1000, replace = TRUE)
plot(grid_sample)
dens(grid_sample)

curve(dbeta(x, 7, 4), from =0, to = 1, add = TRUE, lty = 2)
```


# Summarizing Samples from Posterior

# Intervals of defined boundaries

```{r}
sum(posterior[pgrid < .5]) #Posterior probability below 0.5 using grid approximated posterior


sum(grid_sample < .5)/ 1000 # Using samples of posterior

sum(grid_sample > .25 & grid_sample < .75)/ 1e3 # Posterior probability between .25 and .75


quantile(grid_sample, .25) #gives boundary for lower 25% of posterior
quantile(grid_sample, c(.25, .75)) #middle 50% of data

```


# Intervals of defined mass

```{r}
PI(grid_sample, prob = .5) #middle 50% with equal tails
HPDI(grid_sample, prob = .5) #highest density 50%
```


# Point Estimates

```{r}
pgrid[which.max(posterior)] # Mode of posterior

chainmode(grid_sample) # Mode of sampled posterior
mean(grid_sample)
median(grid_sample)
```


# Minimizing Loss

```{r}
# Probability of pgrid * loss if true value is pgrid
sum(posterior * abs(.5-pgrid))

loss <- sapply(pgrid, function(x) sum(posterior * abs(x - pgrid)))

pgrid[which.min(loss)] # returns median



# Function for mean
loss <- sapply(pgrid, function(x) sum(posterior * (x - pgrid)^2))

pgrid[which.min(loss)]


```


# Simulating Model by sampling appropriate distribution with prior for parameter value

```{r}
globe_toss <- rbinom(1e5, 10, prob = 0.7)

table(globe_toss)/1e5

simplehist(globe_toss)
```

# Alternate way to simulate globe tossing model

```{r}
sim_globe <- function(N = 9, p = 0.7) {
  sample(c("W", "L"), size = N, replace = TRUE, prob = c(p, 1-p))
}

sim_globe()
```

# Build an estimator with sim_globe

```{r}
compute_posterior <- function(the_sample, poss = c(0, .25, .50, .75, 1)) {
  W <- sum(the_sample == "W")
  L <- sum(the_sample == "L")
  ways <- sapply(poss, function(p) ((length(poss) - 1)*p)^W * ((length(poss)-1)*(1-p))^L)
  post <- ways/sum(ways)
  bars <- sapply(post, function(q) make_bar(q))
  data.frame(poss, ways, post=round(post, 3), bars)
}

compute_posterior(sim_globe())

pgrid <- seq(0,1, length.out = 100)
test <- compute_posterior(sim_globe(), poss = pgrid)
plot(test$poss, test$post)
```


# Building Posterior Predictive Disribution using samples from posterior

```{r}
dens(grid_sample)

ppd <- rbinom(1e4, size = 9, prob = grid_sample)

simplehist(ppd)

table(ppd)/1e4

```










